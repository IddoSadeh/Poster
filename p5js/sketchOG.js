// ===== POSTER ANIMATION WITH EDGE-TRACED DOTS =====
// Dots are generated by tracing the edges of each element

const BASE_W = 1080;
const BASE_H = 1350;
const BG_HEX = "#D9DDE6";

// ===== Assets =====
let numbersImg, topSVG, addrSVG, botLSVG, timesImg, langImg, cornerSVG;

// ===== Element positions (BASE coords) =====
const items = {
  top:   { x: 440.46, y:  98.68, w: 534.19, h: 208.81 },
  addr:  { x: 131.05, y: 353.93, w: 607.86, h:  86.84 },
  botL:  { x: 130.26, y:1156.06, w: 833.34, h: 102.25 },
  times: { x: 132.63, y: 683.17, w: 320.80, h:  85.63 },
  lang:  { x: 130.79, y: 795.01, w: 516.03, h: 102.70 }
};

const CUT = { yMin: 255, yMax: 565 };
const NUM_BASE_ALPHA = 70;
const OVERLAY_NUM_ALPHA = 55;
const COVER_ALPHA = 300;
const GLOW_ALPHA = 66;
const GLOW_BLUR_PX = 35;

// ===== Timeline (seconds) =====
const T0_STATIC = 2;      // poster only
const T1_SHOW   = 2;      // show frame around title
const T2_MOVE   = 1.5;    // frame moves to corners
// Dots start appearing at T0 + T1 + T2

// ===== Dot Settings =====
const DOT_CONFIG = {
  // Dot appearance
  fill: [255, 255, 255],
  stroke: [0, 149, 255],
  strokeWeight: 0.8,
  
  // Per-element settings: spacing, radius, and edge detection thresholds
  // Higher thresholds = tighter to solid letters (ignores glow/blur)
  numbers2026: { spacing: 8,  radius: 3.5, solidThreshold: 200, emptyThreshold: 180 },
  times:       { spacing: 6,  radius: 3.0, solidThreshold: 128, emptyThreshold: 100 },
  language:    { spacing: 6,  radius: 3.0, solidThreshold: 128, emptyThreshold: 100 },
  address:     { spacing: 5,  radius: 2.0, solidThreshold: 128, emptyThreshold: 100 },
  topBlock:    { spacing: 5,  radius: 2.0, solidThreshold: 128, emptyThreshold: 100 },
  bottomLeft:  { spacing: 5,  radius: 2.0, solidThreshold: 128, emptyThreshold: 100 },
  
  // Animation
  growDuration: 0.4,    // seconds to grow each dot
  stagger: 0.0005       // seconds between each dot (0 = all at once)
};

// ===== Overlay handles =====
const DOT_SIZE  = 18;
const DOT_INSET = 10;
const DOT_ALPHA = 255;
const TITLE_PAD = 26;
const POSTER_MARGIN_X = 12;
const POSTER_MARGIN_Y = 12;

// ===== Internals =====
let cnv;
let maskSoft, coverLayer, glowLayer, posterLayer;

// Generated dots organized by element
let dots = {
  numbers2026: [],
  times: [],
  language: [],
  address: [],
  topBlock: [],
  bottomLeft: []
};

let dotsReady = false;

function preload() {
  numbersImg = loadImage("2026.png");
  topSVG     = loadImage("topBlock.svg");
  addrSVG    = loadImage("addressBlock.svg");
  botLSVG    = loadImage("bottomLeft.svg");
  timesImg   = loadImage("Times.png");
  langImg    = loadImage("Language.png");
  cornerSVG  = loadImage("Group 70.svg");
}

function setup() {
  cnv = createCanvas(BASE_W, BASE_H);
  pixelDensity(1);
  smooth();
  fitCanvasToWindow();

  // Build layers
  maskSoft = buildSoftAlphaMask(numbersImg);
  coverLayer = makeCoverLayer(maskSoft, COVER_ALPHA);
  glowLayer = makeGlowLayer(maskSoft);

  // Pre-render poster
  posterLayer = createGraphics(BASE_W, BASE_H);
  posterLayer.pixelDensity(1);
  renderPosterTo(posterLayer);

  // Generate dots by tracing edges
  generateAllDots();
}

// ===== EDGE TRACING DOT GENERATION =====

function generateAllDots() {
  console.log("Generating dots from edges...");
  const dotifyStart = T0_STATIC + T1_SHOW + T2_MOVE;
  let globalIndex = 0;

  // 1. Numbers (2026) - trace the full-canvas numbers image
  const numbersConfig = DOT_CONFIG.numbers2026;
  const numbersG = createGraphics(BASE_W, BASE_H);
  numbersG.pixelDensity(1);
  numbersG.clear();
  numbersG.image(numbersImg, 0, 0, BASE_W, BASE_H);
  const numbersEdges = traceEdgesFromGraphics(numbersG, {
    solidThreshold: numbersConfig.solidThreshold,
    emptyThreshold: numbersConfig.emptyThreshold
  });
  const sampledNumbers = samplePoints(numbersEdges, numbersConfig.spacing);
  sampledNumbers.forEach((p, i) => {
    dots.numbers2026.push(createDot(p.x, p.y, numbersConfig.radius, dotifyStart, globalIndex++));
  });
  console.log(`  numbers2026: ${dots.numbers2026.length} dots`);

  // 2. Times
  const timesConfig = DOT_CONFIG.times;
  const timesG = renderElementToGraphics(timesImg, items.times);
  const timesEdges = traceEdgesFromGraphics(timesG, {
    solidThreshold: timesConfig.solidThreshold,
    emptyThreshold: timesConfig.emptyThreshold
  });
  const sampledTimes = samplePoints(timesEdges, timesConfig.spacing);
  sampledTimes.forEach((p, i) => {
    dots.times.push(createDot(p.x, p.y, timesConfig.radius, dotifyStart, globalIndex++));
  });
  console.log(`  times: ${dots.times.length} dots`);

  // 3. Language
  const langConfig = DOT_CONFIG.language;
  const langG = renderElementToGraphics(langImg, items.lang);
  const langEdges = traceEdgesFromGraphics(langG, {
    solidThreshold: langConfig.solidThreshold,
    emptyThreshold: langConfig.emptyThreshold
  });
  const sampledLang = samplePoints(langEdges, langConfig.spacing);
  sampledLang.forEach((p, i) => {
    dots.language.push(createDot(p.x, p.y, langConfig.radius, dotifyStart, globalIndex++));
  });
  console.log(`  language: ${dots.language.length} dots`);

  // 4. Address
  const addrConfig = DOT_CONFIG.address;
  const addrG = renderElementToGraphics(addrSVG, items.addr);
  const addrEdges = traceEdgesFromGraphics(addrG, {
    solidThreshold: addrConfig.solidThreshold,
    emptyThreshold: addrConfig.emptyThreshold
  });
  const sampledAddr = samplePoints(addrEdges, addrConfig.spacing);
  sampledAddr.forEach((p, i) => {
    dots.address.push(createDot(p.x, p.y, addrConfig.radius, dotifyStart, globalIndex++));
  });
  console.log(`  address: ${dots.address.length} dots`);

  // 5. Top block
  const topConfig = DOT_CONFIG.topBlock;
  const topG = renderElementToGraphics(topSVG, items.top);
  const topEdges = traceEdgesFromGraphics(topG, {
    solidThreshold: topConfig.solidThreshold,
    emptyThreshold: topConfig.emptyThreshold
  });
  const sampledTop = samplePoints(topEdges, topConfig.spacing);
  sampledTop.forEach((p, i) => {
    dots.topBlock.push(createDot(p.x, p.y, topConfig.radius, dotifyStart, globalIndex++));
  });
  console.log(`  topBlock: ${dots.topBlock.length} dots`);

  // 6. Bottom left
  const botConfig = DOT_CONFIG.bottomLeft;
  const botG = renderElementToGraphics(botLSVG, items.botL);
  const botEdges = traceEdgesFromGraphics(botG, {
    solidThreshold: botConfig.solidThreshold,
    emptyThreshold: botConfig.emptyThreshold
  });
  const sampledBot = samplePoints(botEdges, botConfig.spacing);
  sampledBot.forEach((p, i) => {
    dots.bottomLeft.push(createDot(p.x, p.y, botConfig.radius, dotifyStart, globalIndex++));
  });
  console.log(`  bottomLeft: ${dots.bottomLeft.length} dots`);

  const total = Object.values(dots).reduce((sum, arr) => sum + arr.length, 0);
  console.log(`âœ… Total dots generated: ${total}`);
  dotsReady = true;
}

function createDot(x, y, r, baseTime, index) {
  return {
    x: x,
    y: y,
    r: r,
    currentR: 0,
    startTime: baseTime + (index * DOT_CONFIG.stagger)
  };
}

function renderElementToGraphics(img, item) {
  const g = createGraphics(BASE_W, BASE_H);
  g.pixelDensity(1);
  g.clear();
  g.image(img, item.x, item.y, item.w, item.h);
  return g;
}

function traceEdgesFromGraphics(g, options = {}) {
  const edges = [];
  g.loadPixels();
  
  const w = g.width;
  const h = g.height;
  const pixels = g.pixels;
  
  // Thresholds - higher values = tighter to the solid part (ignores glow)
  const solidThreshold = options.solidThreshold || 180;  // pixel is "solid" if alpha > this
  const emptyThreshold = options.emptyThreshold || 150;  // pixel is "empty" if alpha < this
  
  // Find edge pixels (where solid meets non-solid)
  for (let y = 1; y < h - 1; y++) {
    for (let x = 1; x < w - 1; x++) {
      const idx = (y * w + x) * 4;
      const alpha = pixels[idx + 3];
      
      // This pixel must be solid
      if (alpha > solidThreshold) {
        // Check if any neighbor is NOT solid (making this an edge)
        const neighbors = [
          ((y - 1) * w + x) * 4,     // top
          ((y + 1) * w + x) * 4,     // bottom
          (y * w + (x - 1)) * 4,     // left
          (y * w + (x + 1)) * 4,     // right
        ];
        
        let isEdge = false;
        for (const nIdx of neighbors) {
          if (pixels[nIdx + 3] < emptyThreshold) {
            isEdge = true;
            break;
          }
        }
        
        if (isEdge) {
          edges.push({ x, y });
        }
      }
    }
  }
  
  return edges;
}

function samplePoints(edges, spacing) {
  if (edges.length === 0) return [];
  
  // Use a grid-based sampling to ensure even distribution
  const sampled = [];
  const grid = new Set();
  
  const cellSize = spacing;
  
  for (const p of edges) {
    const cellX = Math.floor(p.x / cellSize);
    const cellY = Math.floor(p.y / cellSize);
    const key = `${cellX},${cellY}`;
    
    if (!grid.has(key)) {
      grid.add(key);
      sampled.push(p);
    }
  }
  
  return sampled;
}

// ===== MAIN DRAW LOOP =====

function draw() {
  drawingContext.globalCompositeOperation = "source-over";
  drawingContext.filter = "none";

  // Draw pre-rendered poster
  image(posterLayer, 0, 0);

  const t = millis() / 1000;

  // Corner handles animation
  drawOverlayHandles(t);

  // Draw dots
  if (dotsReady) {
    drawAllDots(t);
  }
}

function drawAllDots(tSec) {
  const dotifyStart = T0_STATIC + T1_SHOW + T2_MOVE;
  if (tSec < dotifyStart) return;

  push();
  fill(DOT_CONFIG.fill[0], DOT_CONFIG.fill[1], DOT_CONFIG.fill[2]);
  stroke(DOT_CONFIG.stroke[0], DOT_CONFIG.stroke[1], DOT_CONFIG.stroke[2]);
  strokeWeight(DOT_CONFIG.strokeWeight);

  for (const groupName of Object.keys(dots)) {
    for (const dot of dots[groupName]) {
      const elapsed = tSec - dot.startTime;
      if (elapsed < 0) continue;

      const progress = Math.min(1, elapsed / DOT_CONFIG.growDuration);
      const eased = easeOutCubic(progress);
      dot.currentR = dot.r * eased;

      if (dot.currentR > 0.1) {
        circle(dot.x, dot.y, dot.currentR * 2);
      }
    }
  }

  pop();
}

// ===== POSTER RENDERING =====

function renderPosterTo(g) {
  g.push();
  g.clear();
  g.background(BG_HEX);

  // Numbers base
  g.push();
  g.tint(255, NUM_BASE_ALPHA);
  g.image(numbersImg, 0, 0, BASE_W, BASE_H);
  g.pop();

  // Glow
  g.push();
  g.tint(255, GLOW_ALPHA);
  g.image(glowLayer, 0, 0, BASE_W, BASE_H);
  g.pop();

  // Foreground elements
  g.image(topSVG, items.top.x, items.top.y, items.top.w, items.top.h);
  g.image(addrSVG, items.addr.x, items.addr.y, items.addr.w, items.addr.h);
  g.image(timesImg, items.times.x, items.times.y, items.times.w, items.times.h);
  g.image(langImg, items.lang.x, items.lang.y, items.lang.w, items.lang.h);
  g.image(botLSVG, items.botL.x, items.botL.y, items.botL.w, items.botL.h);

  // Cover in CUT zone
  drawClippedTo(g, coverLayer, 0, CUT.yMin, BASE_W, CUT.yMax - CUT.yMin);

  // Overlay number in CUT zone
  g.push();
  g.tint(255, OVERLAY_NUM_ALPHA);
  drawClippedTo(g, numbersImg, 0, CUT.yMin, BASE_W, CUT.yMax - CUT.yMin);
  g.pop();

  g.pop();
}

function drawClippedTo(g, img, x, y, w, h) {
  g.drawingContext.save();
  g.drawingContext.beginPath();
  g.drawingContext.rect(x, y, w, h);
  g.drawingContext.clip();
  g.image(img, 0, 0, BASE_W, BASE_H);
  g.drawingContext.restore();
}

// ===== OVERLAY HANDLES =====

function drawOverlayHandles(tSec) {
  const titleRect = rectUnion(
    { x: items.times.x, y: items.times.y, w: items.times.w, h: items.times.h },
    { x: items.lang.x,  y: items.lang.y,  w: items.lang.w,  h: items.lang.h }
  );

  const r1 = padRect(titleRect, TITLE_PAD);
  const r2 = {
    x: POSTER_MARGIN_X,
    y: POSTER_MARGIN_Y,
    w: BASE_W - POSTER_MARGIN_X * 2,
    h: BASE_H - POSTER_MARGIN_Y * 2
  };

  const t0 = T0_STATIC;
  const t1 = T0_STATIC + T1_SHOW;
  const t2 = T0_STATIC + T1_SHOW + T2_MOVE;

  if (tSec < t0) return;

  if (tSec < t1) {
    drawCornerDots(r1, 1);
    return;
  }

  const u = clamp01((tSec - t1) / (t2 - t1));
  const e = easeInOutCubic(u);
  const r = lerpRect(r1, r2, e);
  drawCornerDots(r, 1);
}

function drawCornerDots(r, alpha01) {
  const a = Math.round(DOT_ALPHA * alpha01);
  const pts = [
    { x: r.x + DOT_INSET,       y: r.y + DOT_INSET },
    { x: r.x + r.w - DOT_INSET, y: r.y + DOT_INSET },
    { x: r.x + DOT_INSET,       y: r.y + r.h - DOT_INSET },
    { x: r.x + r.w - DOT_INSET, y: r.y + r.h - DOT_INSET }
  ];

  const hasSVG = cornerSVG && cornerSVG.width > 0;

  for (const p of pts) {
    push();
    imageMode(CENTER);
    tint(255, a);

    if (hasSVG) {
      image(cornerSVG, p.x, p.y, DOT_SIZE, DOT_SIZE);
    } else {
      noFill();
      stroke(58, 141, 237, a);
      strokeWeight(2);
      circle(p.x, p.y, DOT_SIZE);
      fill(58, 141, 237, a);
      noStroke();
      circle(p.x, p.y, DOT_SIZE * 0.35);
    }
    pop();
  }
}

// ===== MASK/GLOW HELPERS =====

function buildSoftAlphaMask(srcImg) {
  const m = createImage(srcImg.width, srcImg.height);
  m.loadPixels();
  srcImg.loadPixels();
  for (let i = 0; i < srcImg.pixels.length; i += 4) {
    m.pixels[i + 0] = 255;
    m.pixels[i + 1] = 255;
    m.pixels[i + 2] = 255;
    m.pixels[i + 3] = srcImg.pixels[i + 3];
  }
  m.updatePixels();
  return m;
}

function makeCoverLayer(alphaMask, coverAlpha) {
  const g = createGraphics(BASE_W, BASE_H);
  g.pixelDensity(1);
  g.background(BG_HEX);
  const img = g.get();
  img.mask(alphaMask);
  img.loadPixels();
  for (let i = 0; i < img.pixels.length; i += 4) {
    img.pixels[i + 3] = Math.min(255, Math.round(img.pixels[i + 3] * (coverAlpha / 255)));
  }
  img.updatePixels();
  return img;
}

function makeGlowLayer(alphaMask) {
  const g = createGraphics(BASE_W, BASE_H);
  g.pixelDensity(1);
  g.background(255);
  const img = g.get();
  img.mask(alphaMask);
  const gg = createGraphics(BASE_W, BASE_H);
  gg.pixelDensity(1);
  gg.drawingContext.filter = `blur(${GLOW_BLUR_PX}px)`;
  gg.image(img, 0, 0, BASE_W, BASE_H);
  return gg.get();
}

// ===== LAYOUT =====

function fitCanvasToWindow() {
  const scale = Math.min(windowWidth / BASE_W, windowHeight / BASE_H);
  const cssW = Math.round(BASE_W * scale);
  const cssH = Math.round(BASE_H * scale);
  cnv.style("width", cssW + "px");
  cnv.style("height", cssH + "px");
  cnv.position((windowWidth - cssW) / 2, (windowHeight - cssH) / 2);
}

function windowResized() {
  fitCanvasToWindow();
}

// ===== UTILS =====

function clamp01(x) { return Math.max(0, Math.min(1, x)); }
function lerpRect(r1, r2, t) {
  return {
    x: lerp(r1.x, r2.x, t),
    y: lerp(r1.y, r2.y, t),
    w: lerp(r1.w, r2.w, t),
    h: lerp(r1.h, r2.h, t)
  };
}
function padRect(r, p) {
  return { x: r.x - p, y: r.y - p, w: r.w + p * 2, h: r.h + p * 2 };
}
function rectUnion(a, b) {
  const x1 = Math.min(a.x, b.x);
  const y1 = Math.min(a.y, b.y);
  const x2 = Math.max(a.x + a.w, b.x + b.w);
  const y2 = Math.max(a.y + a.h, b.y + b.h);
  return { x: x1, y: y1, w: x2 - x1, h: y2 - y1 };
}
function easeInOutCubic(t) {
  return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}
function easeOutCubic(t) {
  return 1 - Math.pow(1 - t, 3);
}
